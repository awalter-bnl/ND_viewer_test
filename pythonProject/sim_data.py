from scipy import ndimage as ndi
from scipy.stats import norm
import numpy as np
import xarray as xr


def kreios_3d_k_space(energy_range=(-1, 12),
                      mode='MM_constant_E',
                      temp=30, noise_fraction=0.1):
    """Generates a 3D k-space volume (kx, ky, Ebinding)

    This function will return a 3D k-space volume (in-plane momentum and binding
    energy) that mimics what would be generated by a Kreios momentum microscope.

    Parameters
    ----------
    energy_range : (float, float)
        Tuple giving the (min energy, max energy) for the volume.
    mode : string
        String indicating the 'mode' the Krieos would be in for this 3D space.
    temp : float
        The temperature, in K, that the sample is at for this 3D space.
    noise_fraction : float
        The noise_fraction level to add to the 3D spectra, the noise level is
        calculated using the equation:
            noise=max_3Dvolume*noise*np.random.uniform(-1,1,size=grid.shape)

    """
    # set the x, y and energy ranges based on (min,max,step) tuples
    if mode == 'MM_constant_E':
        x_range = (-3.6, 3.61, 0.08)  # use 0.008 based on Kreios 150MM specs
        y_range = (-3.6, 3.61, 0.08)  # use 0.008 based on Kreios 150MM specs
        z_range = (energy_range[0], energy_range[1],
                   np.sign(energy_range[1] - energy_range[0]) * 0.10)
        labels = ('kx', 'ky', 'Eb')
    elif mode == 'MM_constant_ky':
        x_range = (-3.6, 3.61, 0.008)  # use 0.008 based on Kreios 150MM specs
        y_range = (-3.6, 3.61, 0.1)  # use 0.1 based on Kreios 150MM specs
        z_range = (energy_range[0], energy_range[1],
                   np.sign(energy_range[1] - energy_range[0]) * 0.050)
        labels = ('kx', 'ky', 'Eb')
    else:
        raise ValueError(f'Mode passed in ({mode}) does not match required '
                         f'values of "MM_constant_E" or "MM_constant_ky"')

    x_array = np.arange(*x_range)
    y_array = np.arange(*y_range)
    z_array = np.arange(*z_range)

    def _calc_val(_i, _j, _k,
                  _x_array=x_array, _y_array=y_array, _z_array=z_array,
                  _temp=30, broadening=0.1):
        """Calculates the intensity of the 3D volume at the i,j,k index point.

        This function is designed to return the intensity of the 3D volume
        spectra for the index point i,j,k corresponding to the position
        x_array[i],y_array[j],z_array[k]. This is done assuming the z axis is
        the energy axis, and applies a fermi-function to this axis as well as
        varying the broadening as a function of this value.

        i,j,k : ints
            integers indicating the position in the 3D array at which the
            intensity should be calculated.
        x_array, y_array, z_array : lists
            Lists indicating the relation ship between the indices i,j,k and the
             values x,y,z.
        temp : float
            The temperature, in K, that the sample is at for this 3D space.
        broadening : float
            The amount of broadening to apply to the spectra, based on the
            equation:
                broadening=(max_x*broadening)*(z-2*min_z)/max_z)
        """
        # The radial location in x-y.
        r = (_x_array[_i] ** 2 + _y_array[_j] ** 2) ** 0.5
        # parabolic band shape
        peak_pos = np.sqrt(abs(1.59 * (max(_z_array) - _z_array[_k]) /
                               max(_z_array)))
        # Peak width is a function of z and the maximum x_array value.
        peak_width = (max(_x_array) * broadening) * (
                (_z_array[_k] - 2 * min(_z_array)) / max(_z_array))
        # The fermi function value to apply (1/(exp((z/kT)+1))
        fermi = 1 / (np.exp(-1 * _z_array[_k] / (8.62E-5 * _temp)) + 1)
        # generate the intensity
        intensity = fermi * norm(loc=peak_pos, scale=peak_width).pdf(r)

        return intensity

    # generate the 3D volume.
    grid = np.fromfunction(_calc_val, (len(x_array), len(y_array),
                                       len(z_array)),
                           _x_array=x_array, _y_array=y_array, _z_array=z_array,
                           _temp=temp, dtype=int)
    # apply the symmetry to the bands
    temp_grid = np.copy(grid)
    mask = np.copy(grid)
    temp_grid.fill(0)
    for i in range(len(x_array)):
        for j in range(len(y_array)):
            for k in range(len(z_array)):
                if i - round(2 * 1.59 / x_range[2]) >= 0:
                    temp_grid[i][j][k] = grid[i - round(2 * 1.59 /
                                                        x_range[2])][j][k]

                if np.sqrt(x_array[i] ** 2 + y_array[j] ** 2) > 3.6:
                    mask[i, j, k] = 0
                else:
                    mask[i, j, k] = 1

    for angle in [0, 60, 120, 180, 240, 300]:
        grid += ndi.rotate(temp_grid, angle, reshape=False)

    # add some noise
    grid = grid + grid.max() * noise_fraction * np.random.uniform(
        -1, 1, size=grid.shape)
    # apply the vision limit mask
    grid = grid * mask
    # convert to an x-array

    grid_xr = xr.DataArray(grid, coords={labels[0]: x_array, labels[1]: y_array,
                                         labels[2]: z_array},
                           dims=labels)
    return grid_xr
